# PostgreSQL Cluster Service Contracts
#
# This file defines the service contracts for the PostgreSQL cluster.
# These are not the final Kubernetes manifests (those will be generated by OpenTofu/Helm),
# but rather the API contracts that clients (applications, administrators) will use.

---
# Contract 1: Cluster-Internal Access (Applications in K8s)
# This service provides database access for applications running inside the Kubernetes cluster.

apiVersion: v1
kind: Service
metadata:
  name: postgres-ha-postgresql
  namespace: postgresql
  labels:
    app: postgresql
    component: primary
    managed-by: helm
  annotations:
    description: "PostgreSQL primary instance for application database connections"

spec:
  type: ClusterIP

  # Service IP is assigned by Kubernetes (stable for service lifetime)
  # Example: 10.43.100.50
  clusterIP: <assigned-by-kubernetes>

  ports:
    - name: postgresql
      port: 5432
      targetPort: postgresql
      protocol: TCP

  selector:
    # Routes traffic to primary instance only (writes)
    app: postgresql
    role: primary

  sessionAffinity: None

# Client Connection String (from Kubernetes pods):
# postgresql://username:password@postgres-ha-postgresql.postgresql.svc.cluster.local:5432/database_name
#
# DNS Resolution:
#   Full: postgres-ha-postgresql.postgresql.svc.cluster.local
#   Short (same namespace): postgres-ha-postgresql
#
# Environment Variables (application pods):
#   POSTGRES_HOST: postgres-ha-postgresql.postgresql.svc.cluster.local
#   POSTGRES_PORT: 5432
#   POSTGRES_USER: <from-secret>
#   POSTGRES_PASSWORD: <from-secret>
#   POSTGRES_DB: <application-database>

---
# Contract 2: Read Replica Access (Optional - for read-heavy workloads)
# This service provides load-balanced access to replica instances for read-only queries.

apiVersion: v1
kind: Service
metadata:
  name: postgres-ha-postgresql-read
  namespace: postgresql
  labels:
    app: postgresql
    component: replica
    managed-by: helm
  annotations:
    description: "PostgreSQL replica instances for read-only database connections"

spec:
  type: ClusterIP
  clusterIP: <assigned-by-kubernetes>

  ports:
    - name: postgresql
      port: 5432
      targetPort: postgresql
      protocol: TCP

  selector:
    # Routes traffic to replica instances only (reads)
    app: postgresql
    role: replica

  sessionAffinity: None

# Client Connection String (read-only queries):
# postgresql://username:password@postgres-ha-postgresql-read.postgresql.svc.cluster.local:5432/database_name
#
# Usage Pattern:
#   Write queries → postgres-ha-postgresql (primary)
#   Read queries → postgres-ha-postgresql-read (replicas)

---
# Contract 3: External Access (Internal Network Administrators)
# This service provides database access for administrators on the internal network.

apiVersion: v1
kind: Service
metadata:
  name: postgres-ha-postgresql-external
  namespace: postgresql
  labels:
    app: postgresql
    component: external
    managed-by: helm
  annotations:
    description: "PostgreSQL external access for internal network administrators"
    metallb.universe.tf/address-pool: cluster-vlan-pool

spec:
  type: LoadBalancer

  # MetalLB assigns an IP from the cluster VLAN IP pool
  # Example: 192.168.10.100
  loadBalancerIP: <assigned-by-metallb>

  # Restrict LoadBalancer to specific source IPs (management VLAN)
  # This is enforced at FortiGate firewall level, not Kubernetes
  loadBalancerSourceRanges:
    - 192.168.10.0/24  # Cluster VLAN (for testing)
    - 192.168.1.0/24   # Management VLAN (for administrators)

  ports:
    - name: postgresql
      port: 5432
      targetPort: postgresql
      protocol: TCP

  selector:
    # Routes traffic to primary instance only (writes)
    app: postgresql
    role: primary

  sessionAffinity: None

  externalTrafficPolicy: Cluster

# Client Connection String (from internal network):
# postgresql://username:password@<metallb-ip>:5432/database_name
# Example: postgresql://admin:password@192.168.10.100:5432/postgres
#
# Connection Tools:
#   psql: psql -h 192.168.10.100 -p 5432 -U admin -d postgres
#   pgAdmin: Add server with host=192.168.10.100, port=5432
#   DBeaver: JDBC URL: jdbc:postgresql://192.168.10.100:5432/postgres
#
# Network Requirements:
#   - MetalLB IP must be in cluster VLAN subnet (192.168.10.0/24)
#   - FortiGate firewall rules must allow port 5432 from management VLAN
#   - DNS entry (optional): postgres.homelab.local → <metallb-ip>

---
# Contract 4: Headless Service (StatefulSet Pod Discovery)
# This service enables direct pod-to-pod communication for replication.

apiVersion: v1
kind: Service
metadata:
  name: postgres-ha-postgresql-headless
  namespace: postgresql
  labels:
    app: postgresql
    component: headless
    managed-by: helm

spec:
  type: ClusterIP
  clusterIP: None  # Headless service (no cluster IP assigned)

  ports:
    - name: postgresql
      port: 5432
      targetPort: postgresql
      protocol: TCP

  selector:
    app: postgresql

  publishNotReadyAddresses: true  # Allow DNS resolution for not-ready pods

# DNS Records (StatefulSet pod discovery):
#   postgres-ha-postgresql-0.postgres-ha-postgresql-headless.postgresql.svc.cluster.local
#   postgres-ha-postgresql-1.postgres-ha-postgresql-headless.postgresql.svc.cluster.local
#
# Usage:
#   PostgreSQL replication uses headless service for pod-to-pod communication
#   Primary: postgres-ha-postgresql-0.postgres-ha-postgresql-headless
#   Replica: postgres-ha-postgresql-1.postgres-ha-postgresql-headless

---
# Service Contract Summary
#
# Service Name                        | Type          | Purpose                     | Clients
# ------------------------------------|---------------|-----------------------------|--------------------------
# postgres-ha-postgresql              | ClusterIP     | Primary (writes)            | Kubernetes applications
# postgres-ha-postgresql-read         | ClusterIP     | Replicas (reads)            | Kubernetes applications
# postgres-ha-postgresql-external     | LoadBalancer  | Primary (admin access)      | Internal network admins
# postgres-ha-postgresql-headless     | ClusterIP     | Pod discovery (replication) | PostgreSQL pods (internal)
#
# Port: 5432 (standard PostgreSQL port) for all services
# Protocol: TCP

---
# Security Model
#
# Authentication:
#   - All connections require username and password
#   - Credentials stored in Kubernetes Secret: postgres-ha-postgresql-credentials
#   - Secret keys: postgres-password, replication-password
#
# Authorization (PostgreSQL RBAC):
#   - superuser (postgres): Full admin privileges (for DBA tasks)
#   - replication user: Streaming replication only
#   - application users: CONNECT + table-level privileges (SELECT, INSERT, UPDATE, DELETE)
#
# Network Access Control:
#   - ClusterIP services: Accessible only from Kubernetes pods
#   - LoadBalancer service: Accessible from cluster VLAN and management VLAN (FortiGate rules)
#   - No public internet exposure
#
# Encryption:
#   - In-transit: TLS/SSL connection encryption (configurable, not required for homelab)
#   - At-rest: Kubernetes Secret encryption via etcd (default enabled)

---
# Monitoring Endpoints
#
# PostgreSQL Exporter (Prometheus metrics):
#   - Sidecar container in each PostgreSQL pod
#   - Port: 9187
#   - Path: /metrics
#   - ServiceMonitor: postgres-ha-postgresql-metrics
#
# Metrics Exported:
#   - pg_up: PostgreSQL instance health (1 = up, 0 = down)
#   - pg_stat_database_*: Database-level statistics (connections, transactions, conflicts)
#   - pg_stat_replication_*: Replication status (lag, state, sent/received LSN)
#   - pg_stat_bgwriter_*: Background writer statistics
#   - pg_stat_activity_count: Active connections
#
# Grafana Dashboard:
#   - PostgreSQL Overview: Connections, TPS, replication lag
#   - PostgreSQL Performance: Query execution time, cache hit ratio
#   - PostgreSQL Storage: Database size, storage utilization

---
# Failover Behavior
#
# Scenario: Primary instance (pod-0) fails
#
# Step 1: Kubernetes detects pod-0 unhealthy (liveness probe fails)
# Step 2: Kubernetes attempts to restart pod-0 (CrashLoopBackoff if persistent failure)
# Step 3: If pod-0 cannot recover, replica (pod-1) must be manually promoted:
#   - Admin triggers promotion: kubectl exec postgres-ha-postgresql-1 -- pg_ctl promote
#   - Replica becomes primary, starts accepting writes
#   - Service selector remains unchanged (routes to pod labeled "role: primary")
# Step 4: Pod-0 recovers and rejoins as replica (manual reconfiguration required)
#
# Automatic Failover: NOT supported by Bitnami Helm chart (manual promotion required)
# Mitigation: Document failover procedure in runbook, practice failover testing
#
# Alternative: Future enhancement with CloudNativePG operator for automated failover

---
# Backup and Restore Contracts
#
# Backup Creation:
#   - CronJob: postgres-ha-backup
#   - Schedule: Daily at 02:00 UTC
#   - Method: pg_dump (logical backup)
#   - Storage: /backups/postgres/ (PersistentVolume or NFS)
#   - Retention: 7 days
#   - Filename: postgres-backup-<timestamp>.sql.gz
#
# Restore Procedure:
#   1. Copy backup file to pod: kubectl cp backup.sql.gz postgresql/postgres-ha-postgresql-0:/tmp/
#   2. Restore database: kubectl exec -it postgres-ha-postgresql-0 -- psql -U postgres -d <db> -f /tmp/backup.sql
#   3. Verify data integrity: kubectl exec -it postgres-ha-postgresql-0 -- psql -U postgres -d <db> -c "SELECT COUNT(*) FROM <table>;"
#
# Disaster Recovery:
#   - If cluster is completely lost, redeploy via ArgoCD
#   - Restore databases from latest backup
#   - Replication will re-sync automatically after primary is restored

---
# Performance Tuning
#
# Connection Pooling:
#   - Initial: Application-level pooling (psycopg2, JDBC HikariCP)
#   - Future: PgBouncer sidecar if connection exhaustion occurs
#
# Query Performance:
#   - Out of scope: Application-specific query optimization
#   - Use PostgreSQL EXPLAIN ANALYZE for slow queries
#   - Monitor slow query log via Prometheus metrics
#
# Resource Limits (per pod):
#   - CPU: 2 cores (request: 1 core, limit: 2 cores)
#   - Memory: 4GB (request: 2GB, limit: 4GB)
#   - Storage: 50GB per instance (100GB total)
#
# Scaling:
#   - Vertical: Increase CPU/memory limits via Helm values override
#   - Horizontal: Add read replicas (modify instance_count in Helm values)
#   - Storage: Resize PVC via kubectl (if StorageClass supports expansion)

---
# Version Compatibility
#
# PostgreSQL Version: 16.x (latest stable)
# Bitnami Chart Version: 12.x (compatible with PostgreSQL 16)
# Kubernetes Version: 1.28+ (K3s)
# Helm Version: 3.12+
# OpenTofu Version: 1.6+
# MetalLB Version: 0.14.x

---
# References
#
# - Bitnami PostgreSQL HA Chart: https://github.com/bitnami/charts/tree/main/bitnami/postgresql-ha
# - PostgreSQL Documentation: https://www.postgresql.org/docs/16/
# - Kubernetes Service Types: https://kubernetes.io/docs/concepts/services-networking/service/
# - MetalLB Configuration: https://metallb.universe.tf/configuration/
# - PostgreSQL Exporter: https://github.com/prometheus-community/postgres_exporter
